{
  "href": "#/Components/Senders/HttpSender",
  "chip": "S",
  "linkText": "HttpSender",
  "scrapedAt": "2025-10-31T10:55:13.257Z",
  "title": "FF! Doc | HttpSender",
  "headings": [
    {
      "level": 1,
      "text": "Doc"
    },
    {
      "level": 2,
      "text": "HttpSender"
    },
    {
      "level": 3,
      "text": "See also"
    },
    {
      "level": 3,
      "text": "Syntax"
    }
  ],
  "paragraphs": [
    "Expected message format:",
    "GET methods expect a message looking like this:",
    "POST AND PUT methods expect a message similar as GET, or looking like this:",
    "When used as MTOM sender and MTOM receiver doesn't support Content-Transfer-Encoding \"base64\", messages without line feeds will give an error. This can be fixed by setting the Content-Transfer-Encoding in the MTOM sender.",
    "The use of `multi-value` parameters can be achieved by adding multiple parameters with the same name.",
    "This component has no required attributes",
    "Â© 2025 Frank!Framework"
  ],
  "listItems": [
    "Search",
    "Components",
    "Properties",
    "Credential Providers",
    "Servlet Authenticators",
    "WebServiceListener",
    "MqttSender",
    "ApiListener",
    "JsonXsltSender",
    "NetStorageSender",
    "FrankSender",
    "IbisJavaSender",
    "Github - HttpSender Implementation Examples",
    "Javadoc - org.frankframework.http.HttpSender",
    "RAW The input message is sent unchanged as character data, like text, XML or JSON, with possibly parameter data appended. When there are no parameters to be appended, the output of this option is the same as BINAR.",
    "BINARY The input message is sent unchanged as binary or character data. The mimetype and character set on the HTTP entity will determine how the client interprets the data.",
    "URLENCODED Yields a x-www-form-urlencoded form entity",
    "FORMDATA Yields a multipart/form-data form entity",
    "MTOM Yields a MTOM multipart/related form entity",
    "name: optional, used as 'filename' in Content-Disposition",
    "sessionKey: mandatory, refers to contents of part",
    "value: optional, the contents of the part if the sessionKey specified contains no data",
    "mimeType: optional MIME type",
    "CLIENT_CREDENTIALS_BASIC_AUTH Requires tokenEndpoint, clientId and clientSecret to be set. Implements rfc6749. The clientId and clientSecret are sent as basic authorization to the authorization server. The accessToken is then used in the Authorization header to authenticate against the resource server.",
    "CLIENT_CREDENTIALS_QUERY_PARAMETERS Requires tokenEndpoint, clientId and clientSecret to be set. Implements rfc6749. The clientId and clientSecret are sent in the form body to the authorization server. The accessToken is then used in the Authorization header to authenticate against the resource server.",
    "RESOURCE_OWNER_PASSWORD_CREDENTIALS_BASIC_AUTH Requires tokenEndpoint, clientId, clientSecret, username and password to be set. Implements rfc6749. The clientId and clientSecret are sent as basic authorization to the authorization server. The username and password are sent in the form body to the authorization server. The accessToken is then used in the Authorization header to authenticate against the resource server.",
    "RESOURCE_OWNER_PASSWORD_CREDENTIALS_QUERY_PARAMETERS Requires tokenEndpoint, clientId, clientSecret, username and password to be set. Implements rfc6749. The clientId, clientSecret, username and password are sent in the form body to the authorization server. The accessToken is then used in the Authorization header to authenticate against the resource server.",
    "SAML_ASSERTION Requires samlNameId, samlIssuer, samlAudience, samlAssertionExpiry, and a certificate and private key. Generates a new SAML assertion, which will be exchanged for a token by the authorization server. The accessToken is then used in the Authorization header to authenticate against the resource server.",
    "PEM Currently only used by the SignaturePipe to use a PEM certificate directly as a truststore.",
    "PKCS12",
    "JKS",
    "JCEKS",
    "PEM Currently only used by the SignaturePipe to use a PEM certificate directly as a truststore.",
    "PKCS12",
    "JKS",
    "JCEKS",
    "HttpSender",
    "See also",
    "Syntax",
    "Attributes\nOptional",
    "Optional",
    "Forwards"
  ],
  "codeBlocks": [
    "exception",
    "param_name=param_value&another_param_name=another_param_value",
    "param_name=param_value&another_param_name=another_param_value",
    "param_name=param_value\n   another_param_name=another_param_value",
    "param_name=param_value\n   another_param_name=another_param_value",
    "Copy\n<HttpSender />",
    "<HttpSender />",
    "methodType",
    "POST",
    "PUT",
    "PATCH",
    "RAW",
    "BINARY",
    "URLENCODED",
    "FORMDATA",
    "MTOM",
    "methodType=POST",
    "postType=URLENCODED",
    "FORM-DATA",
    "MTOM",
    "methodType=POST",
    "paramsInUrl=false",
    "GET",
    "false",
    "POST",
    "PUT",
    "PATCH",
    "true",
    "true",
    "methodType=GET",
    "methodType=POST",
    "PUT",
    "PATCH",
    "postType=RAW",
    "GET",
    "GET",
    "POST",
    "PUT",
    "PATCH",
    "DELETE",
    "HEAD",
    "REPORT",
    "RAW",
    "POST",
    "PUT",
    "PATCH",
    "PUT",
    "POST",
    "true",
    "true",
    "john.doe",
    "CORPDOMAIN",
    "authAlias",
    "username",
    "password",
    "expires_in",
    "tokenEndpoint",
    "tokenEndpoint",
    "tokenEndpoint",
    "read write",
    "tokenEndpoint",
    "tokenEndpoint",
    "CLIENT_CREDENTIALS_BASIC_AUTH",
    "tokenEndpoint",
    "clientId",
    "clientSecret",
    "clientId",
    "clientSecret",
    "accessToken",
    "CLIENT_CREDENTIALS_QUERY_PARAMETERS",
    "tokenEndpoint",
    "clientId",
    "clientSecret",
    "clientId",
    "clientSecret",
    "accessToken",
    "RESOURCE_OWNER_PASSWORD_CREDENTIALS_BASIC_AUTH",
    "tokenEndpoint",
    "clientId",
    "clientSecret",
    "username",
    "password",
    "clientId",
    "clientSecret",
    "username",
    "password",
    "accessToken",
    "RESOURCE_OWNER_PASSWORD_CREDENTIALS_QUERY_PARAMETERS",
    "tokenEndpoint",
    "clientId",
    "clientSecret",
    "username",
    "password",
    "clientId",
    "clientSecret",
    "username",
    "password",
    "accessToken",
    "SAML_ASSERTION",
    "samlNameId",
    "samlIssuer",
    "samlAudience",
    "samlAssertionExpiry",
    "accessToken",
    "PEM",
    "PKCS12",
    "JKS",
    "JCEKS",
    "keystoreAlias",
    "keystoreAlias",
    "PEM",
    "PKCS12",
    "JKS",
    "JCEKS",
    "true",
    "true",
    "true",
    "true",
    "staleChecking",
    "true",
    "protocol"
  ],
  "excerpt": "Doc\n9.4.0\nSearch\nComponents\nProperties\nCredential Providers\nServlet Authenticators\nResults0\nRelated8\nWebServiceListener\nMqttSender\nApiListener\nJsonXsltSender\nNetStorageSender\nFrankSender\nIbisJavaSender\nHttpSender\nSendersEndpointHTTP\nSender for the HTTP protocol using HttpMethod. By default, any response code outside the 2xx or 3xx range is considered an error and the exception forward of the SenderPipe is followed if present and if there is no forward for the specific HTTP status code. Forwards for specific HTTP codes (e.g. \"200\", \"201\", ...) are returned by this sender, so they are available to the SenderPipe.\n\nExpected message format:\n\nGET methods expect a message looking like this:\n\nparam_name=param_value&another_param_name=another_param_value\n\nPOST AND PUT methods expect a message similar as GET, or looking like this:\n\nparam_name=param_value\n   another_param_name=another_param_value\n\nWhen used as MTOM sender and MTOM receiver doesn't support Content-Transfer-Encoding \"base64\", mess"
}